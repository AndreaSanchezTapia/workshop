[
  {
    "objectID": "1_landforms.html",
    "href": "1_landforms.html",
    "title": "Variedade de Landforms",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\n\n\n\n\n\nNós exploramos três metodologias de classificação de landforms (Anderson et al. 2016; Theobald et al. 2015; Iwahashi & Yamazaki 2022) para definirmos quais delas seriam usadas no cálculo da variedade de landforms. Primeiro, nós classificamos as landforms como Anderson et al. (2016), exceto a landform Flat at the bottom of steep slope. Assim, nossas landforms foram:\n\n3 - Cool Steep Slope\n4 - Warms Steep Slope\n5 - Cliff\n11 - Summit/Ridgetop\n13 - Slope Crest\n21 - Flat Hilltop\n22 - Gentle Slope Hilltop\n23 - Cool Sideslope\n24 - Warm Sideslope\n30 - Dry Flats\n32 - Valley/Toeslope\n39 - Moist Flats\n43 - Cool Footslope\n44 - Warm Sideslope\n\n\n\n\nNós classificamos as landforms pela inclinação do relevo (slope), aspecto (aspect), Índice de Posição Topográfica (TPI) e Índice de Umidade (moisture index). As variáveis foram discretizadas em classes e combinadas para comporem os tipos de landforms. As landforms são classificadas principalmente pelo slope e TPI (Figure 1). O aspect classifica as faces quentes ou frias do relevo e o moisture index classifica as áreas planas em secas ou úmidas.\n\nFigura 1. Classificação de landforms pela The Nature Conservancy para as paisagens na América do Norte.Adaptação de Anderson et al. (2016).\nCada variável foi discretizada em classes para comporem os tipos de landforms. Os limiares (Tabela 1) para a discretização foram definidos por ajustes visuais que melhor representavam as landforms.\n           Tabela 1. Descrição dos limiares de classificação de cada variável em classes.\n\n\n\nVariáveis\nClasses\nLimiar inferior\nLimiar superior\n\n\n\n\nInclinação do relevo\n1\n-1\n2\n\n\nInclinação do relevo\n2\n2\n6\n\n\nInclinação do relevo\n3\n6\n24\n\n\nInclinação do relevo\n4\n24\n35\n\n\nInclinação do relevo\n5\n35\n90\n\n\nTPI\n1\n-Inf\n-15\n\n\nTPI\n2\n-15\n-1\n\n\nTPI\n3\n-1\n30\n\n\nTPI\n4\n30\n975\n\n\nAspecto\n2\n0\n90\n\n\nAspecto\n1\n90\n270\n\n\nAspecto\n2\n270\n360\n\n\nÍndice de Umidade\n0\n-Inf\n30000\n\n\nÍndice de Umidade\n1\n3000\nInf\n\n\n\nEm seguida, as classes foram combinadas pela soma de cada classe multiplicada por um peso. O moisture index foi multiplicado por 1000, aspect por 100, TPI por 10 e slope por 1. Desta forma, o número resultante representa um código descrevendo as classes de cada variável. Por exemplo, 1231 é a classe 1 de moisture index, 2 de aspect, 3 de TPI e 1 de slope. Posteriormente, os valores finais foram convertidos em tipos de landforms, seguindo a Tabela 2.\nTabela 2. Critério de conversão dos códigos da combinação de classes em tipos de landforms.\n\n\n\nCódigo\nTipos de landforms\n\n\n\n\n10\n11\n\n\n11\n11\n\n\n12\n11\n\n\n13\n13\n\n\n14\n11\n\n\n15\n5\n\n\n20\n21\n\n\n21\n21\n\n\n22\n22\n\n\n23\n24\n\n\n24\n24\n\n\n25\n5\n\n\n31\n30\n\n\n32\n32\n\n\n33\n24\n\n\n34\n24\n\n\n35\n5\n\n\n40\n32\n\n\n41\n32\n\n\n42\n32\n\n\n43\n43\n\n\n44\n3\n\n\n45\n5\n\n\n51\n51\n\n\n111\n11\n\n\n112\n11\n\n\n113\n13\n\n\n114\n3\n\n\n115\n5\n\n\n121\n21\n\n\n122\n22\n\n\n123\n23\n\n\n124\n3\n\n\n125\n5\n\n\n131\n30\n\n\n132\n32\n\n\n133\n23\n\n\n134\n3\n\n\n135\n5\n\n\n141\n32\n\n\n142\n32\n\n\n143\n43\n\n\n144\n3\n\n\n145\n5\n\n\n151\n51\n\n\n211\n11\n\n\n212\n11\n\n\n213\n13\n\n\n214\n4\n\n\n215\n5\n\n\n221\n21\n\n\n222\n22\n\n\n223\n24\n\n\n224\n4\n\n\n225\n5\n\n\n231\n30\n\n\n232\n32\n\n\n233\n24\n\n\n234\n4\n\n\n235\n5\n\n\n241\n32\n\n\n242\n32\n\n\n243\n44\n\n\n244\n4\n\n\n245\n5\n\n\n251\n51\n\n\n1000\n39"
  },
  {
    "objectID": "1_landforms.html#importando-pacotes-e-inicializando-geemap",
    "href": "1_landforms.html#importando-pacotes-e-inicializando-geemap",
    "title": "Variedade de Landforms",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\n\n\n\n\n\nNós exploramos três metodologias de classificação de landforms (Anderson et al. 2016; Theobald et al. 2015; Iwahashi & Yamazaki 2022) para definirmos quais delas seriam usadas no cálculo da variedade de landforms. Primeiro, nós classificamos as landforms como Anderson et al. (2016), exceto a landform Flat at the bottom of steep slope. Assim, nossas landforms foram:\n\n3 - Cool Steep Slope\n4 - Warms Steep Slope\n5 - Cliff\n11 - Summit/Ridgetop\n13 - Slope Crest\n21 - Flat Hilltop\n22 - Gentle Slope Hilltop\n23 - Cool Sideslope\n24 - Warm Sideslope\n30 - Dry Flats\n32 - Valley/Toeslope\n39 - Moist Flats\n43 - Cool Footslope\n44 - Warm Sideslope\n\n\n\n\nNós classificamos as landforms pela inclinação do relevo (slope), aspecto (aspect), Índice de Posição Topográfica (TPI) e Índice de Umidade (moisture index). As variáveis foram discretizadas em classes e combinadas para comporem os tipos de landforms. As landforms são classificadas principalmente pelo slope e TPI (Figure 1). O aspect classifica as faces quentes ou frias do relevo e o moisture index classifica as áreas planas em secas ou úmidas.\n\nFigura 1. Classificação de landforms pela The Nature Conservancy para as paisagens na América do Norte.Adaptação de Anderson et al. (2016).\nCada variável foi discretizada em classes para comporem os tipos de landforms. Os limiares (Tabela 1) para a discretização foram definidos por ajustes visuais que melhor representavam as landforms.\n           Tabela 1. Descrição dos limiares de classificação de cada variável em classes.\n\n\n\nVariáveis\nClasses\nLimiar inferior\nLimiar superior\n\n\n\n\nInclinação do relevo\n1\n-1\n2\n\n\nInclinação do relevo\n2\n2\n6\n\n\nInclinação do relevo\n3\n6\n24\n\n\nInclinação do relevo\n4\n24\n35\n\n\nInclinação do relevo\n5\n35\n90\n\n\nTPI\n1\n-Inf\n-15\n\n\nTPI\n2\n-15\n-1\n\n\nTPI\n3\n-1\n30\n\n\nTPI\n4\n30\n975\n\n\nAspecto\n2\n0\n90\n\n\nAspecto\n1\n90\n270\n\n\nAspecto\n2\n270\n360\n\n\nÍndice de Umidade\n0\n-Inf\n30000\n\n\nÍndice de Umidade\n1\n3000\nInf\n\n\n\nEm seguida, as classes foram combinadas pela soma de cada classe multiplicada por um peso. O moisture index foi multiplicado por 1000, aspect por 100, TPI por 10 e slope por 1. Desta forma, o número resultante representa um código descrevendo as classes de cada variável. Por exemplo, 1231 é a classe 1 de moisture index, 2 de aspect, 3 de TPI e 1 de slope. Posteriormente, os valores finais foram convertidos em tipos de landforms, seguindo a Tabela 2.\nTabela 2. Critério de conversão dos códigos da combinação de classes em tipos de landforms.\n\n\n\nCódigo\nTipos de landforms\n\n\n\n\n10\n11\n\n\n11\n11\n\n\n12\n11\n\n\n13\n13\n\n\n14\n11\n\n\n15\n5\n\n\n20\n21\n\n\n21\n21\n\n\n22\n22\n\n\n23\n24\n\n\n24\n24\n\n\n25\n5\n\n\n31\n30\n\n\n32\n32\n\n\n33\n24\n\n\n34\n24\n\n\n35\n5\n\n\n40\n32\n\n\n41\n32\n\n\n42\n32\n\n\n43\n43\n\n\n44\n3\n\n\n45\n5\n\n\n51\n51\n\n\n111\n11\n\n\n112\n11\n\n\n113\n13\n\n\n114\n3\n\n\n115\n5\n\n\n121\n21\n\n\n122\n22\n\n\n123\n23\n\n\n124\n3\n\n\n125\n5\n\n\n131\n30\n\n\n132\n32\n\n\n133\n23\n\n\n134\n3\n\n\n135\n5\n\n\n141\n32\n\n\n142\n32\n\n\n143\n43\n\n\n144\n3\n\n\n145\n5\n\n\n151\n51\n\n\n211\n11\n\n\n212\n11\n\n\n213\n13\n\n\n214\n4\n\n\n215\n5\n\n\n221\n21\n\n\n222\n22\n\n\n223\n24\n\n\n224\n4\n\n\n225\n5\n\n\n231\n30\n\n\n232\n32\n\n\n233\n24\n\n\n234\n4\n\n\n235\n5\n\n\n241\n32\n\n\n242\n32\n\n\n243\n44\n\n\n244\n4\n\n\n245\n5\n\n\n251\n51\n\n\n1000\n39"
  },
  {
    "objectID": "1_landforms.html#bases-de-dados",
    "href": "1_landforms.html#bases-de-dados",
    "title": "Variedade de Landforms",
    "section": "Bases de dados",
    "text": "Bases de dados\nNós utilizamos para a classificação das landforms o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), o acúmulo de fluxo do Merit-Hydro (Yamazaki et al. 2019) e a camada de uso do solo do MapBiomas (MapBiomas Project 2020). O Modelo Digital de Elevação possui uma resolução de 90 metros e foi escolhido por ser um produto global ao combinar dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. O Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas. Além disso, há um produto derivado, o Merit-Hydro, que disponibiliza o acúmulo de fluxo global, que demandaria grande esforço computacional para ser calculado para todo o Brasil. O Merit-Hydro corrige os efeitos de densidade de árvores no cálculo da rede dendrítica, o que é importante para a Amazônia.\nNós incluímos as classes de água do MapBiomas para complementar a superfície gerada pelo acúmulo de fluxo na definição de áreas planas úmidas. O MapBiomas é um projeto nacional de mapeamento e classificação de mudanças do uso do solo dos últimos 30 anos a partir de dados de sensoriamento remoto."
  },
  {
    "objectID": "1_landforms.html#códigos-para-a-criação-da-variedade-de-landforms",
    "href": "1_landforms.html#códigos-para-a-criação-da-variedade-de-landforms",
    "title": "Variedade de Landforms",
    "section": "Códigos para a criação da variedade de landforms",
    "text": "Códigos para a criação da variedade de landforms\nNossas análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\n\nInclinação do relevo (slope)\nNós criamos a superfície de slope a partir do Merit-DEM.\n\n# Importando Modelo Digital de Elevação\n\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\n# Calculando o slope\n\nslope = ee.Terrain.slope(DEM)\n\n\n\nAspecto (aspect)\nNós calculamos o aspect do relevo utilizando o mesmo DEM.\n\naspect = ee.Terrain.aspect(DEM)\n\n\n\nÍndice de Posição Topográfica (TPI)\nNós calculamos o Índice de Posição Topográfica (TPI)(Weiss 2001) para cada célula do raster dentro de um kernel circular com 7, 11 e 15 células de raio. O TPI é a diferença média de elevação entre a célula focal e um conjunto de células vizinhas.\n\\(TPI = \\frac{\\sum_{i}^{n}(vizinhança_i - focal)}{n}\\)\na vizinhança i representa cada uma das n células dentro do kernel da célula focal. O índice final é composto pela média de TPI das três janelas, o que permite a consideração de diferentes níveis de resolução da paisagem, tanto local quanto regional (Theobald et al. 2015). Os tamanhos das janelas foram definidos visualmente para que melhor representassem as landforms, principalmente os Summits, Valleys, Toeslopes e Hilltops (flat e gentle). Os tamanhos das janelas também tinham que capturar os Platôs como Summits.\n\n# Função para calcular o TPI\n\ndef calculate_TPI(pixel_size):\n\n  # Calcule a média das células da vizinhança\n\n  focal_mean = DEM.focalMean(**{\n                       'radius': pixel_size,\n                       'kernelType': \"circle\",\n                       'units': \"pixels\"\n                     })\n\n  # Calcule a diferença entre a ćelula focal e média da região \n\n  TPI = focal_mean.subtract(DEM)\n\n  return TPI\n\n\n# Tamanho das janelas \n\nwindow_size = [7,11,15]\n\n# Calculo do TPI para cada janela e calculo do TPI médio das janelas\n\nTPI = ee.ImageCollection(list(map(calculate_TPI, window_size))).toBands().reduce(\"mean\")\n\n\n\nÍndice de Umidade (Moisture index)\nNós calculamos o moisture index (Anderson et al. 2016) baseado no acúmulo de fluxo presente no Merit-Hydro (Yamazaki et al. 2019), na camada upg, que é calculado sobre o Merit-DEM. O moisture index é calculado da seguinte forma:\n\\(moisture.index = \\frac{\\log(fluxo + 1)}{(slope + 1)} \\times 1000\\)\nonde fluxo é o acúmulo de fluxo e slope é o slope calculado anteriormente. O moisture index é a média do índice dentro de um kernel circular de uma célula de raio. O tamanho do raio foi escolhido visualmente para suavizar o índice, mas representando bem a distribuição dos cursos d’água.\n\n# Importando o acúmulo de fluxo\n\nflow_accumulation = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upg\")\n\n# Calculando o moisture index\n\nmoisture_index = (\n    flow_accumulation\n    .add(ee.Number(1))\n    .divide(slope.add(ee.Number(1)))\n    .log()\n    .multiply(1000)\n    .focalMean(**{'radius': 1,\n                  'kernelType': \"circle\",\n                  'units': \"pixels\"\n                  }\n                )\n)\n\n\n\nConvertendo variáveis em classes\n\n\nInclinação do relevo (slope)\nAs variáveis foram convertidas em classes utilizando a Tabela 1, seguindo Anderson et al. (2016). As classes de slope foram criadas com o seguinte código:\n\nslope_classes = (\n    slope\n    .where(slope.gte(-1).And(slope.lte(2)), 1)\n    .where(slope.gt(2).And(slope.lte(6)), 2)\n    .where(slope.gt(6).And(slope.lte(24)), 3)\n    .where(slope.gt(24).And(slope.lte(35)), 4)\n    .where(slope.gt(35).And(slope.lte(90)), 5)\n)\n\n\n\nAspecto (aspect)\nO aspecto foi escolhido para definir as faces norte e sul do relevo no hemisfério sul.\n\naspect_classes = (\n    aspect\n    .where(aspect.gte(0).And(aspect.lte(90)), 2)\n    .where(aspect.gt(90).And(aspect.lte(270)), 1)\n    .where(aspect.gt(270).And(aspect.lte(360)), 2)\n)\n\n\n\nÍndice de Posição do Relevo (TPI)\nAs classes de TPI foram definidas para representarem bem os Summits, Valleys, Toeslopes e Hilltops, que foram as landforms mais difíceis de ajustar os parâmetros.\n\nTPI_classes = (\n    TPI\n    .where(TPI.lte(-15), 1)\n    .where(TPI.gt(-15).And(TPI.lt(-1)), 2)\n    .where(TPI.gte(-1).And(TPI.lte(30)), 3)\n    .where(TPI.gt(30).And(TPI.lte(975)), 4)\n)\n\n\n\nÍndice de Umidade (moisture index)\nO limiar do índice umidade para classificar as áreas como umidas ou secas foram definidos visualmente para capturarem a distribuição dos cursos d’água sem criar áreas planas secas com excesso de ramificações dendríticas. Grandes rios (ex. Rio Amazonas, represas e lagos) não foram bem representados pelo moisture index, pois classificava somente a partes mais profundas como áreas úmidas, mantendo o restante dos grandes corpos d’água como regiões planas secas. Nós corrigimos essa classificação combinando a área úmidade classificada pelo acúmulo de fluxo com a camada de águas produzida pelo MapBiomas.\n\n# Classificando o índice de umidade em classes\n\nmoisture_classes = (\n    moisture_index.where(moisture_index.lte(3000), 0)\n    .where(moisture_index.gt(3000), 1)\n)\n\n# Importando o dado de uso de solo do Mapbiomas e reprojetando para a escala do DEM\n\nmapbiomas  = (\n    ee.Image(\"projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2\")\n    .select(\"classification_2020\")\n    .reproject('EPSG:4326', None, 92.76624)\n)\n\n# Reclassificando o raster do MapBiomas em água (1) e outras classes (0)\n\nwater = (\n    mapbiomas\n    .where(mapbiomas.eq(33), 1)\n    .where(mapbiomas.neq(33), 0)\n)\n\n# Combinado o índice de umidade com a camada de água e reclassificando\n\nmoisture_classes = moisture_classes.add(water)\n\nmoisture_classes = (\n    moisture_classes\n    .where(moisture_classes.gte(1), 1)\n    .where(moisture_classes.lt(1), 0)\n)\n\n\n\nCombinando as classes\nCombinamos as classes para a geração de um código representativo de cada variável. O moisture index foi multiplicado por 1000, aspect por 100, TPI por 10 e slope por 1.\n\nclasses_collection = ee.Image([moisture_classes.multiply(ee.Number(1000)),\n                                   aspect_classes.multiply(ee.Number(100)),\n                                   TPI_classes.multiply(ee.Number(10)),\n                                   slope_classes])\n\nlandform_combination = classes_collection.reduce(ee.Reducer.sum())\n\n\n\nClassificando os tipos de landforms\nClassificamos os tipos de landforms pelo código gerado anteriormente e ajustamos visualmente alguns códigos para representarem bem as landforms. Por exemplo, o código 11 representa áreas de baixa inclinação do relevo e uma posição do relevo mais alta que o entorno, sendo portanto um topo de montanha (Summit). No entanto, alguns códigos tiveram que ser bem inspecionados para separar alguns tipos de landforms como Sideslopes de Valleys e Toeslopes.\n\nlandform_types = (\n    landform_combination\n    .mask(landform_combination.gt(0))\n    .where(landform_combination.eq(10), 11)\n    .where(landform_combination.eq(11), 11)\n    .where(landform_combination.eq(12), 11)\n    .where(landform_combination.eq(13), 13)\n    .where(landform_combination.eq(14), 11)\n    .where(landform_combination.eq(15), 5)\n    .where(landform_combination.eq(20), 21)\n    .where(landform_combination.eq(21), 21)\n    .where(landform_combination.eq(22), 22)\n    .where(landform_combination.eq(23), 24)\n    .where(landform_combination.eq(24), 24)\n    .where(landform_combination.eq(25), 5)\n    .where(landform_combination.eq(31), 30)\n    .where(landform_combination.eq(32), 32)\n    .where(landform_combination.eq(33), 24)\n    .where(landform_combination.eq(34), 24)\n    .where(landform_combination.eq(35), 5)\n    .where(landform_combination.eq(40), 32)\n    .where(landform_combination.eq(41), 32)\n    .where(landform_combination.eq(42), 32)\n    .where(landform_combination.eq(43), 43)\n    .where(landform_combination.eq(44), 3)\n    .where(landform_combination.eq(45), 5)\n    .where(landform_combination.eq(51), 51)\n    .where(landform_combination.eq(111), 11)\n    .where(landform_combination.eq(112), 11)\n    .where(landform_combination.eq(113), 13)\n    .where(landform_combination.eq(114), 3)\n    .where(landform_combination.eq(115), 5)\n    .where(landform_combination.eq(121), 21)\n    .where(landform_combination.eq(122), 22)\n    .where(landform_combination.eq(123), 23)\n    .where(landform_combination.eq(124), 3)\n    .where(landform_combination.eq(125), 5)\n    .where(landform_combination.eq(131), 30)\n    .where(landform_combination.eq(132), 32)\n    .where(landform_combination.eq(133), 23)\n    .where(landform_combination.eq(134), 3)\n    .where(landform_combination.eq(135), 5)\n    .where(landform_combination.eq(141), 32)\n    .where(landform_combination.eq(142), 32)\n    .where(landform_combination.eq(143), 43)\n    .where(landform_combination.eq(144), 3)\n    .where(landform_combination.eq(145), 5)\n    .where(landform_combination.eq(151), 51)\n    .where(landform_combination.eq(211), 11)\n    .where(landform_combination.eq(212), 11)\n    .where(landform_combination.eq(213), 13)\n    .where(landform_combination.eq(214), 4)\n    .where(landform_combination.eq(215), 5)\n    .where(landform_combination.eq(221), 21)\n    .where(landform_combination.eq(222), 22)\n    .where(landform_combination.eq(223), 24)\n    .where(landform_combination.eq(224), 4)\n    .where(landform_combination.eq(225), 5)\n    .where(landform_combination.eq(231), 30)\n    .where(landform_combination.eq(232), 32)\n    .where(landform_combination.eq(233), 24)\n    .where(landform_combination.eq(234), 4)\n    .where(landform_combination.eq(235), 5)\n    .where(landform_combination.eq(241), 32)\n    .where(landform_combination.eq(242), 32)\n    .where(landform_combination.eq(243), 44)\n    .where(landform_combination.eq(244), 4)\n    .where(landform_combination.eq(245), 5)\n    .where(landform_combination.eq(251), 51)\n    .where(landform_combination.gte(1000), 39)\n)\n\n\n\nExportando mapas para assets\n\n# Nome do asset\nassetId = \"projects/ee-lucasljardim9/assets/landform_types\"\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nescala = landform_types.projection().nominalScale()\n\n\n# Exportando para o gee\ngeemap.ee_export_image_to_asset(\n    landform_types, description='landform_types', assetId=assetId, region=bioma_box, scale=escala,maxPixels=1e13\n)\n\n\n\nExemplo de landforms\nAbaixo está uma representação das landforms na região de Alto Paraíso de Goiás-GO (Latitude:-14.11, Longitude:-47.26).\n\n%%capture --no-display\n\n# Delimitando a região\nregiao = ee.Geometry.BBox(-47.4631, -13.9777, -47.1005, -14.1711)\n\n# Creando a pasta para exportar as figuras\nif not os.path.exists(\"figura\"):\n    \n    os.mkdir(\"figura\")\n\n# Exportando a imagem da região\ngeemap.ee_export_image(\n    landform_types, filename=\"figura/landform_types.tif\", scale=escala, region=regiao, file_per_band=False\n)\n\n\n# Paleta de cores das landforms\npalette = [\n    \"#ffc408\", # 3\n    \"#ffa101\", # 4\n    \"#ef595a\", # 5\n    \"#ffbdbe\", # 11\n    \"#6e4100\", # 13\n    \"#af7b53\", # 21\n    \"#c8f6ad\", # 23\n    \"#c8c284\", # 22\n    \"#83e763\", # 24\n    \"#08a702\", # 43\n    \"#ffffbe\", # 30\n    \"#a9a800\", # 32\n    \"#b671f2\", # 39\n    \"#0a7000\" ] # 44\n\n# Discretinzando a paleta de cores\ncmap = ListedColormap(\n   palette, 'Custom cmap')\n\nclass_bins = [3, 4, 5, 11, 13, 21, 22, 23, 24, 30, 32, 39, 43, 45]\n\nnorm = BoundaryNorm(class_bins, \n                    13)\n\n# Plotando mapa \ngeemap.plot_raster(\"figura/landform_types.tif\", cmap = cmap, norm = norm, figsize = [20, 10])\n\n\n\n\n      Figura 2. Landforms classificadas na região de Alto Paraíso de Goiás-GO, Brasil."
  },
  {
    "objectID": "1_landforms.html#calculando-a-variedade-de-landforms",
    "href": "1_landforms.html#calculando-a-variedade-de-landforms",
    "title": "Variedade de Landforms",
    "section": "Calculando a variedade de landforms",
    "text": "Calculando a variedade de landforms\nA variedade de landforms foi calculada como a soma de tipos diferentes de landforms dentro de um kernel circular de uma célula focal. O tamanho do raio do kernel foi definido calculando a variedade em diferentes raios (2, 5, 7, 10, 15, 20 células) e calculando o ganho de variedade a cada aumento de raio. O raio escolhido foi aquele que o subsequente não adicionou variedade. Desta forma, o raio representa o nível de resolução da paisagem que captura o máximo de variedade de landforms. Raios maiores podem aumentar a variedade, mas devido a mudança de paisagem. Assim, o raio escolhido foi de 5 células de raio (450 metros) para todo o Brasil. Abaixo está uma representação da variedade de landforms para a mesma região de Alto Paraíso de Goiás-GO.\n\nradius_pixels = 5\n\nlandform_variety = (\n    landform_types\n    .neighborhoodToBands(ee.Kernel.circle(radius_pixels))\n    .reduce(ee.Reducer.countDistinct())\n)\n\n\n%%capture --no-display\n\ngeemap.ee_export_image(\n    landform_variety, filename=\"figura/landform_variety.tif\", scale=escala, region=regiao, file_per_band=False\n)\n\n\ngeemap.plot_raster(\"figura/landform_variety.tif\", figsize = [20, 10])\n\n\n\n\n        Figura 3. Variedade de landforms para região de Alto Paraíso de Goiás-GO, Brasil.\n\nassetId = \"projects/ee-lucasljardim9/assets/landform_variety\"\n\ngeemap.ee_export_image_to_asset(\n    landform_variety, \n    description='landform_variety', \n    assetId=assetId, \n    region=bioma_box, \n    scale=escala,maxPixels=1e13\n)"
  },
  {
    "objectID": "1_landforms.html#bibliografia",
    "href": "1_landforms.html#bibliografia",
    "title": "Variedade de Landforms",
    "section": "Bibliografia",
    "text": "Bibliografia\nAnderson, M.G., Barnett, A., Clark, M., Ferree, C., Sheldon, A.O., Prince, J. 2016. Resilient Sites for Terrestrial Conservation in Eastern North America. The Nature Conservancy. http://easterndivision.s3.amazonaws.com/Resilient_Sites_for_Terrestrial_Conservation.pdf.\nFarr, T.G., et al. 2007. The shuttle radar topography mission. Reviews of Geophysics, 45, 2, RG2004, https://doi.org/10.1029/2005RG000183.\nGorelick, N., Hancher, M., Dixon, M., Ilyushchenko, S., Thau, D., Moore, R. 2017. Google Earth Engine: Planetary-scale geospatial analysis for everyone. Remote Sensing of Environment, 202, 18-27, https://doi.org/10.1016/j.rse.2017.06.031.\nMapBiomas Project. 2020. Collection 7 of the Annual Series of Land Use and Land Cover Maps of Brazil. Accessed on 2023 through the link: projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2.\nPython Software Foundation. Python Language Reference. http://www.python.org.\nTadono, T., Ishida, H., Oda, F., Naito, S., Minakawa, K., Iwamoto, H. 2014. Precise Global DEM Generation by ALOS PRISM. Precise Global DEM Generation by ALOS PRISM. ISPRS Annals of the Photogrammetry, Remote Sensing and Spatial Information Sciences, II-4, 71–76, https://doi.org/10.5194/isprsannals-ii-4-71-2014.\nTheobald, D.M., Harrison-Atlas, D., Monahan, W.B., Albano, C.M. 2015. Ecologically-relevant maps of landforms and physiographic diversity for climate adaptation planning. Plos One, 12, 1-17, https://doi.org/10.1371/journal.pone.0143619.\nYamazaki, D., Ikeshima, D., Tawatari, R., Yamaguchi, T, O’Loughlin, F., Neal, J.C., Sampson, C.C., Kanae, S., Bates, P.D. 2017. A high-accuracy map of global terrain elevations. Geophysical Research Letters, 11, 5844-5853, doi:10.1002/2017GL072874.\nYamazaki, D., Ikeshima, D., Sosa, J., Bates, Paul, D., Allen, G.H., Pavelsky, T.M. 2019. MERIT Hydro: A High-Resolution Global Hydrography Map Based on Latest Topography Dataset. Water Resources Research, 6, 5053-5073, https://doi.org/10.1029/2019WR024873.\nIwahashi, J., Yamazaki, D. 2022. Global polygons for terrain classification divided into uniform slopes and basins. Progress in Earth and Planetary Science, 9, 33, https://doi.org/10.1186/s40645-022-00487-2.\nWeiss, A.D., 2001. Topographic position and landforms analysis. Poster Presentation, ESRI Users Conference, San Diego, CA.\nWu, Q. 2020. geemap: A Python package for interactive mapping with Google. Journal of Open Source Software, 5, 51, 2305, https://doi.org/10.21105/joss.02305."
  },
  {
    "objectID": "2_elevation_range.html",
    "href": "2_elevation_range.html",
    "title": "Amplitude de Elevação",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\nA amplitude de elevação foi calculada como a diferença entre a elevação máxima e mínima dentro da vizinhaça da célula focal. Como essa métrica é correlacionada com a variedade de landforms, nós calculamos o resíduos de uma regressão (Ordinary Least Squares) entre as duas váriaveis. Assim, a amplitude de elevação residual é independente da variedade de landforms, permitindo a identificação de locais que tenham maior variabilidade microclimática que a proporcionada pela variedade de landforms, quando compormos o índice de diversidade da paisagem."
  },
  {
    "objectID": "2_elevation_range.html#importando-pacotes-e-inicializando-geemap",
    "href": "2_elevation_range.html#importando-pacotes-e-inicializando-geemap",
    "title": "Amplitude de Elevação",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\nA amplitude de elevação foi calculada como a diferença entre a elevação máxima e mínima dentro da vizinhaça da célula focal. Como essa métrica é correlacionada com a variedade de landforms, nós calculamos o resíduos de uma regressão (Ordinary Least Squares) entre as duas váriaveis. Assim, a amplitude de elevação residual é independente da variedade de landforms, permitindo a identificação de locais que tenham maior variabilidade microclimática que a proporcionada pela variedade de landforms, quando compormos o índice de diversidade da paisagem."
  },
  {
    "objectID": "2_elevation_range.html#base-de-dados",
    "href": "2_elevation_range.html#base-de-dados",
    "title": "Amplitude de Elevação",
    "section": "Base de Dados",
    "text": "Base de Dados\nNós utilizamos o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), na escala de 90 metros. O Merit-DEM é um produto global que combina dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. Além disso, o Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas.\nA variedade de landforms foi calculada anteriormente (veja o capítulo Variedade de Landforms) e está disponível com asset em “projects/ee-lucasljardim9/assets/landform_variety”.\nAs análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises."
  },
  {
    "objectID": "2_elevation_range.html#códigos-para-o-cálculo-da-amplitude-de-elevação-residual",
    "href": "2_elevation_range.html#códigos-para-o-cálculo-da-amplitude-de-elevação-residual",
    "title": "Amplitude de Elevação",
    "section": "Códigos para o cálculo da amplitude de elevação residual",
    "text": "Códigos para o cálculo da amplitude de elevação residual\nNossas análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\nNós importamos os rasters do modelo digital de elevação e da variedade de landforms.\n\n# Importando o modelo digital de elevação\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# Importando a variedade de landforms calculada anteriormente\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\n#Escala dos rasters ~92 metros\nescala = DEM.projection().nominalScale()\n\nNós extraímos do raster as células dentro da vizinhança (kernel circular com 5 células de raio, ~450 metros) da célula focal e salvamos como bandas de uma imagem. Assim, cada banda é um stack das células da vizinhança da célula focal, a primeira banda possui todas as primeiras células de cada célula focal, a segunda banda todas as segunda células e assim por diante.\n\n# Tamanho do raio do kernel para o calculo da amplitude de elevação\nradius_pixels = 5\n\n# Criando rasters da vizinhança de cada célula como bandas da imagem\nneighbor = DEM.neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels)))\n\nA imagem neighbor criada anteriormente as células da vizinhança como bandas da imagem. Assim, as primeiras células de cada banda são as células da vizinhança da primeira célula focal, organizadas como colunas (bandas). Ao calcularmos os valores máximos e mínimos para cada coluna de neighbor, estamos calculando os valores máximos e mínimos da vizinhança de cada célula focal.\n\n# Calcule o máximo da vizinhança\nelevation_max = neighbor.reduce(ee.Reducer.max())\n\n# Calcule o mínimo da vizinhança\nelevation_min = neighbor.reduce(ee.Reducer.min())\n\nSubtraindo os valores máximos e mínimos de cada célula focal e calculando o seu valor absoluto, temos a amplitude de elevação para cada célula focal. Nós salvamos a amplitude de elevação e variedade de landforms como uma imagem com duas bandas, sendo a primeira banda a variável preditora da regressão e a segunda banda a variável resposta.\n\n# Calcule a amplitude da vizinhança\nelevation_range = elevation_max.subtract(elevation_min).abs()\n\n# Crie uma imagem com as bandas de varidedade de landforms e amplitude de elevação \n# A primeira imagem é o x da regressão e a segunda é o y\n\nelevation = (ee.Image.cat(landform_variety, elevation_range)\n            .rename(['landform_variety', 'elevation_range']))\n\nDesta forma, aplicamos a regressão entre as variáveis.\n\n# Rode uma regressão linear (OLS) entre varidade de landforms e amplitude de elevação\nregression = elevation.reduceRegion(**{\n     'reducer': ee.Reducer.linearFit(),\n     'geometry': bioma_box,\n     'maxPixels': 1e13,\n     'scale': escala\n    })\n\nApós a regressão, multiplicamos a variável preditora pelo coeficiente de regressão (slope) e adicionamos o valor do intercepto para predizermos os valores de amplitude de elevação esperados pela regressão. Em seguida, subtraimos os valores de amplitude de elevação pelos valores preditos pela regressão para calcularmos os resíduos do modelo.\n\n# Calcule o valor predito, pela regressão, de amplitude elevação, sem intercepto \npred = elevation.select('landform_variety').multiply(ee.Number(regression.get('scale')))\n\n# Adicione o intercepto na predição\npredict = pred.add(ee.Number(regression.get('offset')))\n\n# Calcule o residuo da regressão\nresiduals = elevation.select('elevation_range').subtract(predict).rename(['residuals'])\n\nPor fim, exportamos o raster de amplitude de elevação residual como um asset do Google Earth Engine.\n\n# Exporte a amplitude de elevação residual como asset\nassetId = \"projects/ee-lucasljardim9/assets/elevation_range_residual\"\n\ngeemap.ee_export_image_to_asset(\n    residuals, \n    description='elevation_range_residual', \n    assetId=assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)"
  },
  {
    "objectID": "3_wetland_score.html",
    "href": "3_wetland_score.html",
    "title": "Densidade e quantidade de áreas úmidas",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\nO índice Wetland score é uma combinação da densidade de áreas úmidas localmente com a densidade e quantidade de áreas úmidas regionalmente. Wetland score entra no cálculo da diversidade da paisagem em locais planos e úmidos, com baixa variedade de landforms e baixa amplitude de elevação. Nesses locais a variação microclimática seria baixa devido a baixa variabilidade topográfica e geomorfológica, mas como há alta densidade de áreas úmidas, esses locais atuam regulando a variabilidade microclimática localmente, como tampões climáticos, e regulando a emissão de gases de efeito estufa.\nExistem três cenários de distribuição de áreas úmidas, os locais (1) estão presentes em áreas com alta densidade de áreas úmidas no entorno, (2) os locais estão situados em áreas com baixa densidade de áreas úmidas localmente, mas alta densidade regionalmente e (3) os locais estão presentes em áreas com alta quantidade de áreas úmidas, mas baixa densidade devido a sua distribuição espacial. Desta forma, wetland score é composto pelos três cenários citados anteriormente, primeiro é calculado a densidade local, regional e a quantidade regional e, para cada métrica, é calculado um valor de Z, subtraindo pela média e dividindo pelo desvio padrão. A densidade de áreas úmidas é a média ponderada dos valores de Z da densidade local e regional (peso duplo para a densidade local). Nos locais onde os valores de Z da quantidade de áreas úmidas regional é maior que a densidade média calculada anteriormente, o índice torna-se a média ponderada da densidade local, densidade regional e quantidade de áreas úmidas regional (duplo peso para a densidade local).\n\\[\n\\tiny\nwetland.score =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]\nNesse capítulo demonstraremos como as densidades e a quantidade de áreas úmidas foram calculadas e em outro capítulo mostraremos como calculamos os valores de Z e o wetland score."
  },
  {
    "objectID": "3_wetland_score.html#importando-pacotes-e-inicializando-geemap",
    "href": "3_wetland_score.html#importando-pacotes-e-inicializando-geemap",
    "title": "Densidade e quantidade de áreas úmidas",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\nO índice Wetland score é uma combinação da densidade de áreas úmidas localmente com a densidade e quantidade de áreas úmidas regionalmente. Wetland score entra no cálculo da diversidade da paisagem em locais planos e úmidos, com baixa variedade de landforms e baixa amplitude de elevação. Nesses locais a variação microclimática seria baixa devido a baixa variabilidade topográfica e geomorfológica, mas como há alta densidade de áreas úmidas, esses locais atuam regulando a variabilidade microclimática localmente, como tampões climáticos, e regulando a emissão de gases de efeito estufa.\nExistem três cenários de distribuição de áreas úmidas, os locais (1) estão presentes em áreas com alta densidade de áreas úmidas no entorno, (2) os locais estão situados em áreas com baixa densidade de áreas úmidas localmente, mas alta densidade regionalmente e (3) os locais estão presentes em áreas com alta quantidade de áreas úmidas, mas baixa densidade devido a sua distribuição espacial. Desta forma, wetland score é composto pelos três cenários citados anteriormente, primeiro é calculado a densidade local, regional e a quantidade regional e, para cada métrica, é calculado um valor de Z, subtraindo pela média e dividindo pelo desvio padrão. A densidade de áreas úmidas é a média ponderada dos valores de Z da densidade local e regional (peso duplo para a densidade local). Nos locais onde os valores de Z da quantidade de áreas úmidas regional é maior que a densidade média calculada anteriormente, o índice torna-se a média ponderada da densidade local, densidade regional e quantidade de áreas úmidas regional (duplo peso para a densidade local).\n\\[\n\\tiny\nwetland.score =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]\nNesse capítulo demonstraremos como as densidades e a quantidade de áreas úmidas foram calculadas e em outro capítulo mostraremos como calculamos os valores de Z e o wetland score."
  },
  {
    "objectID": "3_wetland_score.html#banco-de-dados",
    "href": "3_wetland_score.html#banco-de-dados",
    "title": "Densidade e quantidade de áreas úmidas",
    "section": "Banco de Dados",
    "text": "Banco de Dados\nNós utilizamos como base de dados de áreas úmidas o Global Wetlands database (Gumbricht et al. 2017). Nós reprojetamos o raster de áreas úmidas para a mesma resolução do modelo digital de elevação usado nas etapas anteriores (~ 90 metros).\nPara calcularmos as densidades e quantidade de áreas úmidas, nós retiramos as áreas úmidas classificadas como sistemas lacustres e ribeirinhos (riverines e lacustrines) e reclassificamos o raster como sendo área úmida (1) ou não sendo área úmida (0). Depois, calculamos a densidade de áreas úmidas dentro de uma vizinhaça de 450 metros (5 células) de raio de um kernel circular (densidade local). Calculamos também a densidade e a quantidade de áreas úmidas na vizinhança de ~ 1170 metros (13 células) (regional)."
  },
  {
    "objectID": "3_wetland_score.html#código-para-calcular-as-densidades-e-quantidade-de-áreas-úmidas",
    "href": "3_wetland_score.html#código-para-calcular-as-densidades-e-quantidade-de-áreas-úmidas",
    "title": "Densidade e quantidade de áreas úmidas",
    "section": "Código para calcular as densidades e quantidade de áreas úmidas",
    "text": "Código para calcular as densidades e quantidade de áreas úmidas\nAs análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\nPrimeiro, nós importamos os polígonos dos biomas do Brasil e extraímos suas coordenadas geográficas máximas e mínimas para delimitar a região de análise. Importamos o modelo digital de elevação e o raster de áreas úmidas e reprojetamos a resolução das áreas úmidas para a resolução do modelo digital de elevação.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas \n# mínimas e máximas do Brasil\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\n# Reprojetando áreas úmidas\nwetlands = (ee.Image(\"projects/ee-lucasljardim9/assets/Cifor_wetlands\") \n            .reproject(**{'crs': \"EPSG:4326\",\n                       'scale': escala}))\n\nEm seguida, retiramos os sistemas ribeirinhos e lacustres do raster de áreas úmidas e reclassificamos as classes do raster em presença e ausência de áreas úmidas.\n\n# Criando uma máscara para rios e lagos\n\nrivers = wetlands.mask(wetlands.neq(10))\n\n# Retirando rios e lagos das áreas úmidas\n\nwetlands = wetlands.mask(rivers)\n\n# Transformando áreas úmidas em um raster binário\n# de presença de áreas úmidas\n\nwetlands_binary = wetlands.where(wetlands.gt(0), 1).unmask()\n\nPosteriomente, nós calculamos a densidade de áreas úmidas, localmente, dentro de um kernel circular de ~450 metros (5 células). Primeiro, transformamos as células da vizinhança de cada célula focal em bandas de uma imagem. Assim, cada células vizinha da célula focal fica empilhada como uma coluna. Para cada coluna, somamos os valores das células (0 ou 1) como a quantidade de áreas úmidas na vizinhança. Depois, dividimos a quantidade de áreas úmidas pelo número de células na vizinhança, resultando na densidade de áreas úmidas.\n\nradius_pixels = 5\n\n# Tranforme as células da vizinha em bandas\n\nneighbors = (wetlands_binary\n            .neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels))))\n\n# Conte a quantidade de áreas úmidas na vizinhança\nwetlands_count = neighbors.reduce(ee.Reducer.sum()).toDouble()\n\n# Conte o número de células totais na vizinhança\n\nneighbors_amount = neighbors.bandNames().length()\n\n#Divida a quantidade de áreas úmidas pelo \n# número de células para calcular a densidade \nwetlands_density_local = wetlands_count.divide(ee.Number(neighbors_amount))\n\nRepetimos o mesmo procedimento da densidade local para calcularmos a densidade e quantidade de áreas úmidas regional.\n\nradius_pixels = 13\n\n# Transforme as células vizinhas em bandas\n\nneighbors = (wetlands_binary\n           .neighborhoodToBands(ee.Kernel.circle(\n                                   ee.Number(radius_pixels)\n                                   )\n                               ))\n\n# Conte a quantidade de áreas úmidas\nwetlands_count = neighbors.reduce(ee.Reducer.sum()).toDouble()\n\n# Conte o número de células totais na vizinhança\nneighbors_amount = neighbors.bandNames().length()\n\n# Calcule a densidade dividindo a quantidade \n# de áreas úmidas pelo número de células\nwetlands_density_regional = wetlands_count.divide(ee.Number(neighbors_amount))\n\nPor fim, exportamos a densidade de áreas úmidas local (wetlands_density), a densidade regional (wetlands_density_1000) e a quantidade regional (wetlands_count) como assets no Google Earth Engine.\n\nassetId_quantidade = \"projects/ee-lucasljardim9/assets/wetlands_count\"\n\nassetId_densidade_local = \"projects/ee-lucasljardim9/assets/wetlands_density\"\n\nassetId_densidade_regional = \"projects/ee-lucasljardim9/assets/wetlands_density_1000\"\n\ngeemap.ee_export_image_to_asset(\n    wetlands_count, \n    description='wetlands_count', \n    assetId=assetId_quantidade, \n    region=bioma_box, \n    scale=escala, maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    wetlands_density_local, \n    description='wetlands_density_local', \n    assetId=assetId_densidade_local, \n    region=bioma_box, \n    scale=escala, maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    wetlands_density_regional, \n    description='wetlands_density_regional', \n    assetId=assetId_densidade_regional, \n    region=bioma_box, \n    scale=escala, maxPixels=1e13\n)"
  },
  {
    "objectID": "4_soil_diversity.html",
    "href": "4_soil_diversity.html",
    "title": "Riqueza de solo",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\nA riqueza de solo é incluída na heterogeneidade da paisagem em locais com baixa variedade de landforms, amplitude altitudinal e índice de áreas úmidas. A riqueza de solos é calculada como a soma dos tipos de solos componentes dos polígonos de solo."
  },
  {
    "objectID": "4_soil_diversity.html#importando-pacotes-e-inicializando-geemap",
    "href": "4_soil_diversity.html#importando-pacotes-e-inicializando-geemap",
    "title": "Riqueza de solo",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\n\n\nA riqueza de solo é incluída na heterogeneidade da paisagem em locais com baixa variedade de landforms, amplitude altitudinal e índice de áreas úmidas. A riqueza de solos é calculada como a soma dos tipos de solos componentes dos polígonos de solo."
  },
  {
    "objectID": "4_soil_diversity.html#banda-de-dados",
    "href": "4_soil_diversity.html#banda-de-dados",
    "title": "Riqueza de solo",
    "section": "Banda de Dados",
    "text": "Banda de Dados\nNós utilizamos a base de dados de pedologia do Instituto Brasileiro de Geografia e Estatística (IBGE) como base para o cálculo da riqueza de solos. Calculamos a quantidade de solos componentes de cada polígono e rasterizados na escala do modelo digital de elevação que usamos nas etapas anteriores (~ 90 metros)."
  },
  {
    "objectID": "4_soil_diversity.html#códigos-para-a-criação-da-diversidade-de-solos",
    "href": "4_soil_diversity.html#códigos-para-a-criação-da-diversidade-de-solos",
    "title": "Riqueza de solo",
    "section": "Códigos para a criação da diversidade de solos",
    "text": "Códigos para a criação da diversidade de solos\nAs análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020), em Python (Python Software Foundation 2023), como interface pela facilidade na documentação e reprodutividade das análises.\nO primeiro passo é criar uma função que conta os tipos de solos componentes de cada polígono. Concatenamos as colunas componente, component1, component2 e component3. Depois, separamos a string pelos sinais de “+”, que indicam as separações das descrições de cada tipo de solo. Em seguida, contamos quantos tipo de solos existem em cada polígono como o comprimento da lista de tipos de solos. Adicionamos uma coluna chamada soil_richness com a riqueza de solos em cada polígono.\n\ndef fun(feature):\n    number = (ee.String(feature.get(\"componente\"))\n              .cat(ee.String(feature.get(\"component1\")))\n              .cat(ee.String(feature.get(\"component2\")))\n              .cat(ee.String(feature.get(\"component3\")))\n              .split(\"\\+\")\n              .length())\n\n    return feature.set(\"soil_richness\", number)\n\nEm seguida, importamos os dados de solo, definimos a região para exportar o dado e a escala da análise.\n\n# Importando os polígonos de solo\nsolo = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/pedo_area\")\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\nAplicamos a função criada anteriormente aos polígonos de solo\n\nsolo = solo.map(fun)\n\nRasterizamos a riqueza de solos na mesma escala das análises anteriores (~90 metros).\n\nsoil_diversity = solo.reduceToImage(**{'properties':[\"soil_richness\"],\n                     'reducer':ee.Reducer.max()}) \\\n                     .reproject(**{'crs':\"EPSG:4326\",\n                                  'scale':escala})\n\nPor fim, exportamos o raster como um asset no Google Earth Engine.\n\n# Exporte o raster de diversidade de solo \nassetId = \"projects/ee-lucasljardim9/assets/soil_diversity\"\n\ngeemap.ee_export_image_to_asset(\n    soil_diversity, description='soil_diversity', assetId=assetId, region=regiao_box, scale=escala, maxPixels=1e13\n)"
  },
  {
    "objectID": "5_Z_scores.html",
    "href": "5_Z_scores.html",
    "title": "Calculando Z-scores das variáveis",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\ngeemap.ee_initialize()\n\n*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_doiqkQG3NJ1t8IS?source=API\nAntes de calcularmos a diversidade da paisagem e a resiliência, nós transformamos as variáveis (variedade de landforms, amplitude altitudinal, densidade, quantidade de áreas úmidas e diversidade de solo) em valores de Z. O cálculo de Z é realizado dentro janelas móveis. Um fato importante é a posterior tranformação dos valores de densidade e quantidade de áreas úmidas em wetland score.\nOs valores de Z de cada variável, em cada célula (i), é o desvio do valor da célula da média da janela móvel (u), divido pelo seu desvio padrão:\n\\[Z-score_{iu} = \\frac{i - media_{u}}{desviopadrao_{u}}\\]\nO wetland score é a média ponderada das densidades locais e regionais de áreas úmidas. Em locais onde o valor de Z da densidade média é menor que o Z da quantidade de áreas úmidas, o wetland score assume o segundo valor Z.\n\\[\n\\tiny\nwetland.score =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]"
  },
  {
    "objectID": "5_Z_scores.html#base-de-dados",
    "href": "5_Z_scores.html#base-de-dados",
    "title": "Calculando Z-scores das variáveis",
    "section": "Base de Dados",
    "text": "Base de Dados\nNós utilizamos as variáveis criadas anteriormente e guardadas como assets no Google Earth Engine. As variáveis são:\n(colocar os links das variáveis aqui)\n\nvariedade de landforms\namplitude de elevação\ndiversidade de solo\nunidades eco-geológicas\nconectividade da paisagem\ndensidade local de áreas úmidas\ndensidade regional de áreas úmidas\nquantidade regional de áreas úmidas"
  },
  {
    "objectID": "5_Z_scores.html#códigos-para-o-cálculo-dos-z-scores",
    "href": "5_Z_scores.html#códigos-para-o-cálculo-dos-z-scores",
    "title": "Calculando Z-scores das variáveis",
    "section": "Códigos para o cálculo dos Z-scores",
    "text": "Códigos para o cálculo dos Z-scores\nAs análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\nPrimeiro, nós criamos uma função para calcular o Z-score dentro de cada janela móvel (code) para cada variável (image). A função calcula a média e desvio padrão para a vizinhança de cada célula, utilizando uma janela móvel circular. Depois, os valores e média e desvio padrão convertidos para Z-score pela subtração variável pela média e divida pelo desvio padrão.\n\nimport ee\n\ndef calculate_Z_scores(image, windows):\n\n  # Calculating the mean\n  mean = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.mean(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Calculating the standard deviation\n  sd = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.stdDev(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Values as a raster\n  meanValue = mean.rename('mean')\n  sdValue = sd.rename('sd')\n\n  # Calculating the z scores\n  z = image.subtract(meanValue).divide(sdValue).rename('z')\n\n  return z\n\nAqui nós importamos as variáveis de interesse para o cálculo de Z.\n\n# Importando as variáveis\n\n#Conferir os links\n\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\nelevation_range = ee.Image(\"projects/ee-lucasljardim9/assets/elevation_range_residual\")\n\nsoil_diversity = ee.Image('projects/ee-lucasljardim9/assets/soil_diversity')\n\nconnectedness = ee.Image(\"projects/ee-lucasljardim9/assets/Biomas_resistencia_kernel\")\n\n# Importando os dados de wetlands para o wetland score\n\nwetlands_count = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_count\")\n\nwetlands_density = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density\")\n\nwetlands_density_1000 = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density_1000\")\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()"
  },
  {
    "objectID": "5_Z_scores.html#calculando-z-scores",
    "href": "5_Z_scores.html#calculando-z-scores",
    "title": "Calculando Z-scores das variáveis",
    "section": "Calculando Z-scores",
    "text": "Calculando Z-scores\nNós aplicamos a função wrap_calculate_Z para cada variável e guardamos o valores de Z calculados.\n\n# Calculando os valores de Z para cada variável\n\nwindows = 200\n\nZ_landform_variety = calculate_Z_scores(landform_variety, windows)\n\nZ_elevation_range = calculate_Z_scores(elevation_range, windows)\n\nZ_soil_diversity = calculate_Z_scores(soil_diversity, windows)\n\nZ_wetlands_count = calculate_Z_scores(wetlands_count, windows)\n\nZ_wetlands_density = calculate_Z_scores(wetlands_density, windows)\n\nZ_wetlands_density_1000 = calculate_Z_scores(wetlands_density_1000, windows)\n\nZ_connectedness = calculate_Z_scores(connectedness, windows).multiply(-1)\n# conferir se precisar multiplicar mesmo po -1"
  },
  {
    "objectID": "5_Z_scores.html#calculando-wetland-score",
    "href": "5_Z_scores.html#calculando-wetland-score",
    "title": "Calculando Z-scores das variáveis",
    "section": "Calculando wetland score",
    "text": "Calculando wetland score\nAqui, nós calculamos o wetland score, aplicando a fórmula descrita anteriormente.\n\n# Calculando a densidade de areas úmidas como a média do local e regional\nwetlands_density = (Z_wetlands_density\n                    .multiply(2)\n                    .add(Z_wetlands_density_1000)\n                    .divide(3))\n\n# Testando se o Z da quantidade de áreas úmidas é maior que a densidade média\n\nwet_test = wetlands_density.lt(Z_wetlands_count)\n\n# Média de densidade local, regional e quantidade de áreas úmidas\nwet_average = (wetlands_density\n              .multiply(3)\n              .add(Z_wetlands_count)\n              .divide(4))\n\n# Substituindo os locais com densidade menor que a quantidade pelos valores de quantidade             \nZ_wetlands_score = Z_wetlands_density.where(wet_test, wet_average)"
  },
  {
    "objectID": "5_Z_scores.html#exportando-os-z-scores",
    "href": "5_Z_scores.html#exportando-os-z-scores",
    "title": "Calculando Z-scores das variáveis",
    "section": "Exportando os Z-scores",
    "text": "Exportando os Z-scores\nPor último, exportamos todas as imagens de Z como asset no Google Earth Engine.\n\n# Criando os links dos assets\nlandform_assetId = \"projects/ee-lucasljardim9/assets/Z_landform_variety\"\n\nelevation_assetId = \"projects/ee-lucasljardim9/assets/Z_elevation_range\"\n\nwetland_assetId = \"projects/ee-lucasljardim9/assets/Z_wetlands_score\"\n\nsoil_assetId = \"projects/ee-lucasljardim9/assets/Z_soil_diversity\"\n\nconnectedness_assetId = \"projects/ee-lucasljardim9/assets/Z_connectedness\"\n\n# Exportando as imagens\ngeemap.ee_export_image_to_asset(\n    Z_landform_variety, \n    description='Z_landform_variety', \n    assetId=landform_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_elevation_range, \n    description='Z_elevation_range', \n    assetId=elevation_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_wetlands_score, \n    description='Z_wetlands_score', \n    assetId=wetland_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_soil_diversity, \n    description='Z_soil_diversity', \n    assetId=soil_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_connectedness, \n    description='Z_connectedness', \n    assetId=connectedness_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)"
  }
]