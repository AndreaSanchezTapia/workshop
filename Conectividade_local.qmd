# Conectividade local

## Bases de dados utilizadas

Os dados espaciais primários utilizados para calcular a superfície de resistência foram a camada de cobertura do solo gerada pelo MapBiomas [@mapbiomas_project_collection_2020]. A esta base foram incluídas as bases de estradas pavimentadas e não pavimentadas fornecida pelo IBGE (BCIM250, ano 2021) e a base de infraestrutura energética fornecidas por...
<!-- Precisamos atualizar a explicação das bases usadas na camada de conectividade --> 

## Cálculo de resistência {-}

Os valores de resistência são medidas relativas do grau de dificuldade de deslocamento dos organismos nos diferentes tipos de cobertura do solo. Esses valores foram atribuídos por bioma, seguindo a premissa de que quanto maior for a diferença estrutural entre um dado tipo de cobertura do solo e a vegetação original do bioma, maior será o valor de resistência da classe de cobertura do solo em questão.

A superfície de cobertura do solo do MapBiomas foi reamostrada para gerar pixels com 90 m de tamanho, aproximadamente. Também convertemos o arquivo vetorial de estradas para o formato matricial, com pixels de tamanho aproximado de 90 m. Conjugamos, por álgebra de mapas, as bases matriciais do MapBiomas e de estradas, de tal maneira que todos os pixels da base do MapBiomas que se sobrepuseram a um pixel de estrada assumiram um novo valor correpondentes a um pixel de estrada pavimentada ou não pavimentada.
<!-- Necessário complementar a explicação da infraestrutura de energia --> 
Os pixels do mapa consolidado de cobertura do solo, já incluindo as estradas pavimentadas e não pavimentadas como novas classes, receberam, separadamente por bioma, valores de resistência que buscaram traduzir, comparativamente entre as classes, o grau de dificuldade de movimentação da biodiversidade numa dada classe de cobertura do solo. Os valores de resistência dos pixels de cada uma das classes foram atribuídos, por bioma, pela equipe do projeto e podem ser vistos na @tbl-resistencia.
<!-- Falta incluir a explicação sobre a análise da largura dos rios --> 

|Classe de cobertura do solo|Amazônia|	Caatinga|	Cerrado	|MataAtlântica|	Pampa	| Pantanal|
|---:|--:|--:|--:|--:|--:|--:|
|Aquaculture|-	|10	|7	|7	|7	|- |
|Beach, Dune and Sand Spot|2	|2	|2	|2	|2	|- |
|Citrus|-	|-	|10	|10	|-	|- |
|Coffee|-	|7	|10	|10	|-	|- |
|Cotton|7	|7	|10	|-	|-	|- |
|Estradas não pavimentadas|10	|10	|7	|10	|7	|7 |
|Estradas pavimentadas|20	|20	|20	|20	|20	|20|
|Forest Formation|1	|1	|1	|1	|1	|1 |
|Forest Plantation|7	|2	|7	|3	|10	|5 |
|Grassland|2	|1	|1	|2	|1	|1 |
|Herbaceous Sandbank Vegetation	|-	|1	|-	|2	|1	|- |
|Mangrove|1	|1	|1	|1	|-	|- |
|Mining|20	|20	|20	|20	|20	|20|
|Mosaic of Uses|7	|7	|10	|10	|10	|10|
|Other non Forest Formations|-	|-	|-	|7	|-	|- |
|Other non Vegetated Areas|-	|9	|10	|10	|10	|10|
|Other Perennial Crops|7	|7	|10	|10	|-	|- |
|Other Temporary Crops|15	|7	|10	|10	|10	|10|
|Pasture|15	|7	|5	|9	|5	|7 |
|Rice|-	|-	|10	|10	|10	|- |
|River, Lake and Ocean|2	|5	|5	|5	|5	|2 |
|Rocky Outcrop|-	|1	|2	|2	|2	|- |
|Salt Flat|2	|1	|2	|2	|-	|- |
|Savanna Formation|2	|1	|1	|2	|-	|2 |
|Soybean|15	|10	|10	|10	|10	|10|
|Sugar cane|15	|10	|10	|10	|-	|10|
|Urban Area|20	|20	|20	|20	|20	|20|
|Wetland| 1	|-	|1	|1	|1	|1 |
|Wooded Sandbank Vegetation|-	|1	|-	|1	|1	|- |
: Valores de resistência para cada tipo de cobertura por bioma. {#tbl-resistencia}

<!-- Precisa atualizar a tabela e também incluir o fluxograma da análise que Marina gerou --> 

## Aplicação do filtro kernel

Depois de atribuídos os valores de resistência, aplicamos à superfície gerada a função _kernel_ de decaimento linear. Esta análise considerou, numa janela móvel de 23 pixels (~2070 m), o contexto espacial em que cada pixel está inserido, reconhecendo que pixels mais próximos possuem uma influência maior que os mais distantes. Desta maneira, a função _kernel_ nos auxilia na tarefa de encontrar os melhores caminhos de deslocamento na paisagem, ou seja, aqueles caminhos que oferecem menor resistência (@fig-res).

![Mapa final de classificação da resistência dos diferentes tipos de uso e cobertura da terra.](figs/C2_Resistencia.png){#fig-res width="400" fig-align="center"}

## Conectividade regional

Calculamos a conectividade regional baseada em teoria de circuitos [@mcrae_isolation_2006] utilizando a implementação de Omniscape para Julia [@hall_circuitscape_2021; @landau_omniscapejl_2021].

Como base para estas análises, utilizamos:

+ o raster de resistência utilizado como base para a conectividade local;
+ um raio da área de interesse de 210 pixels (~19km);
+ agrupamentos de 21 pixels de interesse para a janela móvel (~1.9km).

O raio da área de interesse é o raio de busca ou tamanho da janela móvel circular. O tamanho da janela foi equivalente ao utilizado no cálculo dos Z scores (200 pixels), o valor é levemente diferente devido à limitação do tamanho do bloco central da janela ser um número ímpar de pixels (agrupamento de 21) e segundo @landau_omniscapejl_2021 esse valor não deve ultrapassar 10% do raio.

Consideramos o uso de _kernel_ sobre a superfície de resistência como entrada para o Omniscape, entretanto, os resultados da análise com _kernel_ diluíram muito corredores e passagens menores, por conta da natureza de suavização da superfície de resistência pelo _kernel_. Dessa maneira, ao utilizar a resistência sem _kernel_ como entrada, preservamos estruturas espaciais menores, mas importantes para a conectividade da paisagem.

O _output_ do Omniscape são três arquivos de conectividade relacionados:

+ `flow_current` é o fluxo que aconteceria sem levar em conta a camada de resistência. Ele leva em conta a configuração espacial da paisagem (estreitos, barras) e dos pixels de baixa resistência de origem. Nem todo pixel é _source_ pixel, mas a corrente que entra em cada pixel de baixa resistência entra sem resistência. Flow current é usado como um "modelo nulo" de conectividade.
+ `cummulative_current` é a corrente acumulada, levando em conta a configuração espacial e os valores de resistência.
+ `normalized_current` equivale a $\frac{cumulative\_current}{flow\_current}$
e controla o efeito da configuração espacial do cálculo de conectividade.

Como é uma análise com uma demanda computacional alta, recortamos regiões de interesse em quadrados de 4.000 pixels para cada bioma e avaliamos os diversos cenários para melhor ajuste de parâmetros e tomadas de decisão, como utilizar `cumulative_current` ou `normalized_current` e utilizar a resistência ou a superfície gerada pelo _kernel_.

<!-- Vamos manter essa implementação do Omniscape ou deixamos de fora? --> 

## Implementação do Omniscape

Como utilizar o Omniscape na linguagem Julia:

## 1 - Instalar Julia
Disponível em: https://julialang.org/downloads/
Acessado em 18/08/2022

## 2 - Abrir um terminal e navegar até o diretório onde se encontra o arquivo de resistência
(mesmo diretório de onde se encontrará o arquivo de parâmetros .ini)
Isso pode ser feito através do comando cd (exemplo abaixo)
$cd C:/geo/omniscape

## 3 - Abrir Julia através de um terminal
Podem-se utilizar várias threads para paralelizar os dados.

Caso queira utilizar todas as threads disponíveis, utilizar o comando abaixo no terminal:

$julia --threads auto

Alternativamente, caso queira utilizar um número específico de threads:

$julia --threads X

Onde X é o número de threads desejado. Esse valor pode ser determinado ao olhar as especifícações da CPU.

## 4 - Instalar Omniscape
Com Julia aberto, executar o seguinte comando:

$using Pkg; Pkg.add("Omniscape")

## 5 - Criar um arquivo com a extensão .ini (pode utilizar o bloco de notas e ao invés de salvar como .txt, salvar como .ini).
O arquivo deve ser salvo na mesma pasta onde se encontra o arquivo de resistência.
O arquivo .ini contém os parâmetros a serem utilizados pelo Omniscape, um exemplo segue abaixo:

---------------------------------------------------------
parallelize=true
block_size=21
calc_normalized_current=true
radius=210
resistance_file=resistance.tif
r_cutoff=inf
run_omniscape(path=:String)
write_raw_currmap=true
parallel_batch_size=20
source_from_resistance=true
project_name=omniscape
---------------------------------------------------------

## 6 - Executar o comando abaixo utilizando o arquivo .ini previamente criado como argumento:
$run_omniscape("parametros.ini")

## Observações Importantes

O valor de parallel_batch_size varia muito o tempo de processamento e a demanda da CPU (central processing unit ou processador), valores muito baixos (como o sugerido pelos autores, de 10 ou 20) demandam muito recurso de processamento, enquanto a tarefa demora muito a ser finalizada. Nos testes realizados, percebemos uma grande oscilação da porcentagem de CPU entre 100 e 80% quando valores baixos de parallel_batch_size foram utilizados, em outros testes com valores mais altos o uso de CPU foi estabilizado (oscilando muito pouco) e tempo de processamento reduzido drasticamente. Não há valores ótimos para qualquer tipo de análise, visto que eles dependem do tamanho do raster e da configuração da máquina (especialmente CPU e memória RAM disponível).

Vale ressaltar que a quantidade de threads utilizada para abrir o Julia e consequentemente rodar o Omniscape afeta diretamente o consumo de memória RAM, uma vez que quando mais threads, mais memória será demandada para o processamento.

<!--

Por fim, calculamos os valores de Z para cada pixel ($Z_{pixel}$) ao subtrair o valor da média ($\mu$) e dividindo o resultado pelo desvio padrão ($\sigma$) e multiplicando tudo por -1, como mostrado na fórmula a seguir:
$$
Z_{pixel}= \left(\frac {X_{pixel}-\mu} {\sigma}\right) \times -1
$$
Os cálculos de $Z$ foram feitos dentro de cada classificação de regiões eco-geológicas usando as médias e desvios padrão dentro de cada uma das classes. Multiplicamos o valores por -1 por considerarmos que a conectividade local é o inverso dos valores de resistência suavizados pelo _kernel_.

-->

<!-- Os dados espaciais primários para calcular a superfície de resistência foram a camada de cobertura do solo fornecida pelo MapBiomas [@mapbiomas_project_collection_2020] e a base de estradas fornecida pelo IBGE (BCIM250 de 2021). Os seguintes passos foram realizados:
1.	Os pixels da camada do MapBiomas foram reamostrados de 30 metros par 90 metros, usando a ferramenta “Ressample” do software ArcGis 10.5
2.	O shapefile de estradas do IBGE foi convertido para o formato raster, com pixels de aproximadamente 90 metros de tamanho. Os pixels correspondentes a estradas pavimentadas receberam o valor de 2000, os pixels de estradas não pavimentadas receberam o valor de 1000 e os demais pixels (que não correspondem a nenhuma estrada) receberam o valor de 0 (zero)
3.	No ArcGis 10.5, usando a ferramenta “Map Calculator” as camadas de cobertura do solo e de estradas foram somadas. Na superfície gerada, foram mantidos os valores dos pixels, originalmente atribuídos pelo MapBiomas, quando um pixel de cobertura do solo se sobrepusesse a algum pixel da camada de estradas com valor igual a zero. Nos casos onde os pixels de cobertura do solo se sobrepuseram a um pixel de estrada pavimentadas o valor final desses pixels foi reclassificado para 98 e quando a sobreposição ocorreu com algum pixel de estrada não pavimentada, o valor final foi reclassificado para 99
4.	Na superfície gerada, os pixels de cada uma das classes receberam valores de resistência, inferidos separadamente para cada bioma (obs: neste arquivo os valores de resistência foram inferidos pela equipe de bolsistas de pós-doutorado do Projeto e seus supervisores, com auxílio da equipe da TNC). Os valores de resistência para cada classe de uso e cobertura do solo, por bioma, encontram-se na tabela 1 (abaixo). Os valores de resistência buscaram traduzir, comparativamente entre as classes, o grau de dificuldade de movimentação de um dado animal ou propágulo naquela classe de cobertura do solo. A premissa assumida aqui, para todos os biomas, é que quanto maior fora a diferença estrutural daquela classe para o hábitat original do bioma, maior será a dificuldade de movimentação por um dado pixel
5.	Depois de atribuídos os valores de resistência, usando a ferramenta “Focal Statistics” do ArcGis 10.5, foi calculada o valor médio do pixel focal, em um raio de 23 pixels, aplicando a função de _Kernel_, com decaimento linear. Esta análise considera o contexto espacial em que cada pixel está inserido, reconhecendo que pixels mais próximos possuem uma influência maior um sobre o outro do que pixels mais distantes -->
